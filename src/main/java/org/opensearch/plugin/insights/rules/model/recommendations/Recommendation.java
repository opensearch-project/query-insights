/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

package org.opensearch.plugin.insights.rules.model.recommendations;

import java.io.IOException;
import java.util.Collections;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import org.opensearch.core.common.io.stream.StreamInput;
import org.opensearch.core.common.io.stream.StreamOutput;
import org.opensearch.core.common.io.stream.Writeable;
import org.opensearch.core.xcontent.ToXContentObject;
import org.opensearch.core.xcontent.XContentBuilder;

/**
 * Represents a query recommendation generated by a rule
 */
public class Recommendation implements ToXContentObject, Writeable {
    private final String id;
    private final String ruleId;
    private final String title;
    private final String description;
    private final RecommendationType type;
    private final Action action;
    private final ImpactVector impact;
    private final double confidence;
    private final Map<String, Object> metadata;

    private Recommendation(Builder builder) {
        this.id = builder.id;
        this.ruleId = builder.ruleId;
        this.title = builder.title;
        this.description = builder.description;
        this.type = builder.type;
        this.action = builder.action;
        this.impact = builder.impact;
        this.confidence = builder.confidence;
        this.metadata = builder.metadata != null ? Collections.unmodifiableMap(builder.metadata) : Collections.emptyMap();
    }

    /**
     * Create a Recommendation from a StreamInput
     * @param in the stream input
     * @throws IOException if deserialization fails
     */
    @SuppressWarnings("unchecked")
    public Recommendation(StreamInput in) throws IOException {
        this.id = in.readOptionalString();
        this.ruleId = in.readString();
        this.title = in.readString();
        this.description = in.readString();
        this.type = in.readEnum(RecommendationType.class);
        this.action = in.readOptionalWriteable(Action::new);
        this.impact = in.readOptionalWriteable(ImpactVector::new);
        this.confidence = in.readDouble();
        Map<String, Object> readMetadata = (Map<String, Object>) in.readGenericValue();
        this.metadata = readMetadata != null ? Collections.unmodifiableMap(readMetadata) : Collections.emptyMap();
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        out.writeOptionalString(id);
        out.writeString(ruleId);
        out.writeString(title);
        out.writeString(description);
        out.writeEnum(type);
        out.writeOptionalWriteable(action);
        out.writeOptionalWriteable(impact);
        out.writeDouble(confidence);
        out.writeGenericValue(metadata.isEmpty() ? null : metadata);
    }

    /**
     * @return the recommendation ID
     */
    public String getId() {
        return id;
    }

    /**
     * @return the rule ID that generated this recommendation
     */
    public String getRuleId() {
        return ruleId;
    }

    /**
     * @return the recommendation title
     */
    public String getTitle() {
        return title;
    }

    /**
     * @return the recommendation description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @return the recommendation type
     */
    public RecommendationType getType() {
        return type;
    }

    /**
     * @return the recommended action
     */
    public Action getAction() {
        return action;
    }

    /**
     * @return the estimated impact
     */
    public ImpactVector getImpact() {
        return impact;
    }

    /**
     * @return the confidence level (0.0 to 1.0)
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * @return the metadata map
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        if (id != null) {
            builder.field("id", id);
        }
        builder.field("rule_id", ruleId);
        builder.field("title", title);
        builder.field("description", description);
        builder.field("type", type.toString().toLowerCase(Locale.ROOT));
        if (action != null) {
            builder.field("action", action);
        }
        if (impact != null) {
            builder.field("impact", impact);
        }
        builder.field("confidence", confidence);
        if (metadata != null && !metadata.isEmpty()) {
            builder.field("metadata", metadata);
        }
        builder.endObject();
        return builder;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Recommendation that = (Recommendation) o;
        return Double.compare(that.confidence, confidence) == 0
            && Objects.equals(id, that.id)
            && Objects.equals(ruleId, that.ruleId)
            && Objects.equals(title, that.title)
            && Objects.equals(description, that.description)
            && type == that.type
            && Objects.equals(action, that.action)
            && Objects.equals(impact, that.impact)
            && Objects.equals(metadata, that.metadata);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, ruleId, title, description, type, action, impact, confidence, metadata);
    }

    /**
     * Builder for Recommendation
     */
    public static class Builder {
        private String id;
        private String ruleId;
        private String title;
        private String description;
        private RecommendationType type;
        private Action action;
        private ImpactVector impact;
        private double confidence = 1.0;
        private Map<String, Object> metadata;

        /**
         * Set the recommendation ID
         * @param id the ID
         * @return this builder
         */
        public Builder id(String id) {
            this.id = id;
            return this;
        }

        /**
         * Set the rule ID
         * @param ruleId the rule ID
         * @return this builder
         */
        public Builder ruleId(String ruleId) {
            this.ruleId = ruleId;
            return this;
        }

        /**
         * Set the title
         * @param title the title
         * @return this builder
         */
        public Builder title(String title) {
            this.title = title;
            return this;
        }

        /**
         * Set the description
         * @param description the description
         * @return this builder
         */
        public Builder description(String description) {
            this.description = description;
            return this;
        }

        /**
         * Set the recommendation type
         * @param type the type
         * @return this builder
         */
        public Builder type(RecommendationType type) {
            this.type = type;
            return this;
        }

        /**
         * Set the action
         * @param action the action
         * @return this builder
         */
        public Builder action(Action action) {
            this.action = action;
            return this;
        }

        /**
         * Set the impact vector
         * @param impact the impact
         * @return this builder
         */
        public Builder impact(ImpactVector impact) {
            this.impact = impact;
            return this;
        }

        /**
         * Set the confidence level
         * @param confidence the confidence (0.0 to 1.0)
         * @return this builder
         */
        public Builder confidence(double confidence) {
            this.confidence = confidence;
            return this;
        }

        /**
         * Set the metadata
         * @param metadata the metadata map
         * @return this builder
         */
        public Builder metadata(Map<String, Object> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * Build the Recommendation
         * @return the recommendation
         */
        public Recommendation build() {
            Objects.requireNonNull(ruleId, "ruleId must not be null");
            Objects.requireNonNull(title, "title must not be null");
            Objects.requireNonNull(description, "description must not be null");
            Objects.requireNonNull(type, "type must not be null");
            return new Recommendation(this);
        }
    }

    /**
     * Create a new builder
     * @return a new builder
     */
    public static Builder builder() {
        return new Builder();
    }
}
